<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>구글 도구 활용 시험</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4285f4, #34a853);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .quiz-container {
            padding: 30px;
        }

        .question-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 5px solid #4285f4;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            transition: transform 0.2s ease;
        }

        .question-card:hover {
            transform: translateY(-2px);
        }

        .question-number {
            color: #4285f4;
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .question-text {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 20px;
            line-height: 1.7;
        }

        .options {
            margin-left: 20px;
        }

        .option {
            margin-bottom: 12px;
            padding: 12px;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }

        .option:hover {
            background-color: #e8f0fe;
        }

        .option label {
            cursor: pointer;
            display: flex;
            align-items: flex-start;
            font-size: 1em;
            line-height: 1.5;
        }

        .option input[type="radio"] {
            margin-right: 12px;
            margin-top: 3px;
            transform: scale(1.2);
        }

        .option input[type="checkbox"] {
            margin-right: 12px;
            margin-top: 3px;
            transform: scale(1.2);
        }

        .hint {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-style: italic;
            color: #856404;
        }

        .hint::before {
            content: "💡 힌트: ";
            font-weight: bold;
        }

        .submit-container {
            text-align: center;
            padding: 30px;
            background: #f8f9fa;
        }

        .submit-btn {
            background: linear-gradient(135deg, #4285f4, #34a853);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(66, 133, 244, 0.3);
        }

        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(66, 133, 244, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .results {
            margin-top: 30px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 12px;
            display: none;
        }

        .score-display {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .score-number {
            font-size: 3em;
            font-weight: bold;
            color: #4285f4;
            margin-bottom: 10px;
        }

        .score-text {
            font-size: 1.3em;
            color: #666;
        }

        .question-result {
            margin-bottom: 25px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            border-left: 5px solid #ddd;
        }

        .question-result.correct {
            border-left-color: #34a853;
            background: #f0f9f0;
        }

        .question-result.incorrect {
            border-left-color: #ea4335;
            background: #fef0f0;
        }

        .result-header {
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        .result-icon {
            margin-right: 10px;
            font-size: 1.2em;
        }

        .rationale {
            background: #e8f0fe;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            font-style: italic;
            line-height: 1.6;
        }

        .rationale::before {
            content: "📚 해설: ";
            font-weight: bold;
            font-style: normal;
        }

        .retry-btn {
            background: #f39c12;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 20px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .retry-btn:hover {
            background: #e67e22;
            transform: translateY(-1px);
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .quiz-container {
                padding: 20px;
            }
            
            .question-card {
                padding: 20px;
            }
        }

        .navigation-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 30px;
            background: #f8f9fa;
        }

        #questionCounter {
            font-size: 1.1em;
            font-weight: 500;
            color: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎓 구글 도구 활용 시험</h1>
            <p>총 20문제 | 문제당 5점 | 만점 100점</p>
        </div>

        <div class="quiz-container">
            <form id="quizForm">
                <!-- 문제들이 여기에 동적으로 생성됩니다 -->
            </form>

            <div id="navigation" class="navigation-container" style="display: none;">
                <button type="button" id="prevBtn" class="submit-btn" style="background-color: #6c757d;">이전</button>
                <span id="questionCounter"></span>
                <button type="button" id="nextBtn" class="submit-btn">다음</button>
            </div>

            <div id="results" class="results">
                <!-- 결과가 여기에 표시됩니다 -->
            </div>
        </div>
    </div>

    <script>
        const quizData = {
            "questions": [
              {
                "question": "김 교사는 학급 학생들이 작성한 독후감 중 우수작을 모아 온라인 학급 문집을 만들고, 학부모님들께 공유하려고 합니다. 학생들이 제출한 구글 문서 파일을 손쉽게 취합하고, 전문적인 디자인의 웹페이지로 구현할 수 있는 가장 적합한 도구는 무엇인가요?",
                "answerOptions": [
                  {
                    "text": "Google 설문지",
                    "rationale": "설문지는 주로 의견을 수렴하거나 퀴즈를 만드는 데 사용되며, 여러 개의 문서를 취합하여 시각적으로 보여주는 문집 제작에는 적합하지 않습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "Blogger",
                    "rationale": "블로거는 연대기 순으로 게시물을 올리는 데는 좋지만, 여러 학생의 작품을 체계적으로 정리하고 디자인의 자유도를 높여 웹사이트처럼 만드는 데는 다소 제약이 있습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "Google 사이트 도구",
                    "rationale": "구글 드라이브에 있는 문서들을 페이지에 바로 삽입할 수 있고, 코딩 없이도 깔끔한 디자인의 웹사이트를 만들 수 있어 온라인 문집 제작에 가장 이상적입니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "Google 그룹스",
                    "rationale": "그룹스는 커뮤니티 게시판이나 이메일 목록 관리에 사용하는 도구로, 웹사이트를 제작하는 기능은 없습니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "여러 종류의 콘텐츠(문서, 동영상, 캘린더 등)를 한 페이지에 모아 웹사이트 형태로 만들 수 있는 도구를 생각해 보세요.",
                "type": "single"
              },
              {
                "question": "다음 중 유튜브 동영상을 활용하여 학생들의 학습 참여를 높일 수 있는 방법으로 적절한 것을 <b>모두 고르세요.</b>",
                "answerOptions": [
                  {
                    "text": "자막(CC) 기능을 활용하여 중요한 내용을 시각적으로 강조하고, 외국어 학습 자료로 사용한다.",
                    "rationale": "자동 번역 자막이나 직접 만든 자막을 통해 청각 장애 학생의 접근성을 높이고, 핵심 용어를 반복 노출하거나 어학 학습에 효과적으로 사용할 수 있습니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "Google 설문지를 영상에 삽입(YouTube용 Google Forms 부가기능 등 활용)하여 시청 중 퀴즈를 풀게 한다.",
                    "rationale": "영상을 보다가 중간에 퀴즈를 풀게 하면, 학생들이 내용을 잘 이해하고 있는지 실시간으로 확인하고 수동적인 시청에서 능동적인 학습으로 전환시킬 수 있습니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "영상의 특정 구간에 댓글을 달아 토론을 유도하거나 질문을 하게 한다.",
                    "rationale": "타임스탬프가 있는 댓글 기능은 특정 장면에 대한 구체적인 토론을 가능하게 하여, 학생들 간의 상호작용과 깊이 있는 탐구를 촉진합니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "모든 영상을 2배속으로 보게 하여 수업 시간을 단축한다.",
                    "rationale": "재생 속도 조절은 복습 시 유용할 수 있으나, 일괄적으로 2배속 시청을 강제하는 것은 학습 내용의 이해도를 떨어뜨릴 수 있어 참여를 높이는 보편적인 방법으로 보기 어렵습니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "단순히 영상을 보여주는 것을 넘어, 학생들과 상호작용할 수 있는 유튜브의 다양한 기능을 떠올려 보세요.",
                "type": "multiple"
              },
              {
                "question": "아래의 '과제 유형'과 그에 가장 적합한 '구글 클래스룸 설정'을 올바르게 짝지으세요.<br><br><b>과제 유형</b><br>A. 모든 모둠이 함께 브레인스토밍하는 문서<br>B. 학생 각자가 작성해서 제출해야 하는 활동지<br>C. 과제 안내 및 참고용으로만 제공하는 지도 파일<br><br><b>클래스룸 설정</b><br>1. '각 학생에게 사본 제공'<br>2. '학생들이 파일을 수정할 수 있음'<br>3. '학생들은 파일을 볼 수 있음'",
                "answerOptions": [
                  {
                    "text": "A-2, B-1, C-3",
                    "rationale": "각 과제의 목적에 맞는 파일 공유 방식을 정확하게 연결했습니다. 공동 작업(모두 수정), 개인별 과제(사본 제공), 단순 참고 자료(보기만)의 차이를 이해하고 있습니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "A-1, B-2, C-3",
                    "rationale": "이 조합은 학생들이 서로의 안내문을 수정하게 되는 등 과제의 목적과 설정이 맞지 않는 부분이 있습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "A-3, B-1, C-2",
                    "rationale": "이 조합은 모든 학생이 하나의 활동지를 수정하게 되어 개인별 과제가 불가능해지는 등 설정이 잘못 연결되었습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "A-2, B-3, C-1",
                    "rationale": "개별 활동지에 모든 학생이 수정 권한을 갖게 되면 과제 수행에 큰 혼란이 발생할 수 있습니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "모두가 '함께' 만들어야 하는지, '각자' 해야 하는지, 아니면 그냥 '보기만' 하면 되는지를 기준으로 생각해 보세요.",
                "type": "single"
              },
              {
                "question": "최 교사는 구글 스프레드시트에 정리된 학생들의 학기말 성적 데이터를 분석하고 있습니다. `VLOOKUP` 함수를 사용하여 학생의 '학번'을 입력했을 때, 해당 학생의 '총점'과 '평균'을 다른 시트에서 자동으로 찾아오려고 합니다. `VLOOKUP` 함수를 올바르게 사용하기 위해 반드시 충족되어야 할 조건은 무엇인가요?",
                "answerOptions": [
                  {
                    "text": "데이터가 반드시 날짜 순서로 정렬되어 있어야 한다.",
                    "rationale": "VLOOKUP은 정렬 여부와 관계없이 동작하지만, 근사값 일치(TRUE 옵션)를 사용할 경우에만 정렬이 필요합니다. 정확히 일치하는 값을 찾을 때는 정렬이 필수 조건이 아닙니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "찾으려는 값이(이 경우 '학번') 데이터 범위의 **첫 번째 열**에 있어야 한다.",
                    "rationale": "VLOOKUP 함수의 가장 중요한 제약 조건으로, 함수는 지정된 범위의 첫 번째 열에서만 검색을 수행하고 그 오른쪽 열들의 값을 반환합니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "데이터 범위에 빈 행이 하나도 없어야 한다.",
                    "rationale": "빈 행이 있어도 함수는 정상적으로 동작하지만, 검색 범위 내에 찾는 값이 없다면 오류를 반환할 뿐 빈 행 자체가 함수의 필수 조건은 아닙니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "찾아올 값이(이 경우 '총점' 등) 반드시 숫자로만 구성되어야 한다.",
                    "rationale": "VLOOKUP 함수는 숫자, 텍스트, 날짜 등 다양한 형식의 데이터를 가져올 수 있으며, 반환 값의 형식이 숫자로 제한되지 않습니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "VLOOKUP 함수가 데이터를 검색하는 방향(세로 방향)과 시작점을 생각해 보세요. 어디서부터 찾기 시작해야 할까요?",
                "type": "single"
              },
              {
                "question": "다음 중 학생들의 디지털 리터러시(Digital Literacy) 역량을 향상시키기 위한 구글 도구 활용 방안으로 적절하지 <b>않은</b> 것은?",
                "answerOptions": [
                  {
                    "text": "구글 검색 시, 검색어에 따옴표(\" \")나 마이너스 기호(-)를 사용하여 원하는 정보를 더 정확하고 효율적으로 찾는 방법을 지도한다.",
                    "rationale": "이는 정보 검색의 정확도를 높이는 중요한 검색 연산자 활용법으로, 정보 탐색 및 평가 역량을 길러주는 좋은 예시입니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "구글 알리미(Google Alerts)를 설정하여 특정 키워드(예: '기후 변화')와 관련된 최신 뉴스를 자동으로 수신하고, 정보의 출처를 비판적으로 분석하는 활동을 한다.",
                    "rationale": "새로운 정보를 지속적으로 습득하고, 그 정보의 신뢰도를 판단하는 훈련은 비판적 사고력을 포함한 디지털 리터러시의 핵심 요소입니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "학생들에게 점수를 잘 받기 위해 위키피디아의 내용을 그대로 복사하여 보고서에 붙여넣도록 장려한다.",
                    "rationale": "이는 표절에 해당하며, 정보의 올바른 인용 및 저작권 존중이라는 디지털 윤리를 심각하게 위배하는 활동입니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "구글 사이트 도구로 '가짜 뉴스 판별법'에 대한 안내 사이트를 만들게 하여, 정보의 사실 여부를 확인하는 다양한 방법을 스스로 탐구하고 공유하게 한다.",
                    "rationale": "이는 학생들이 정보의 소비자를 넘어 생산자로서 책임감을 갖고, 미디어를 비판적으로 이해하는 역량을 기르는 매우 효과적인 프로젝트입니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "디지털 리터러시는 단순히 도구를 잘 쓰는 것을 넘어, 정보를 책임감 있고 윤리적으로 다루는 태도를 포함합니다.",
                "type": "single"
              },
              {
                "question": "학생들과 함께 '우리 동네 역사 지도'를 만드는 프로젝트를 진행하고 있습니다. 다음 중 이 프로젝트를 수행하기 위해 <b>구글 내 지도(Google My Maps)</b>를 활용할 때의 장점으로 옳은 것을 <b>모두 고르세요.</b>",
                "answerOptions": [
                  {
                    "text": "특정 장소에 마커(핀)를 표시하고, 그곳에 관련된 사진, 동영상, 설명 글을 추가할 수 있다.",
                    "rationale": "내 지도의 핵심 기능으로, 지도 위에 다양한 멀티미디어 정보를 층층이 쌓아 풍부한 컨텍스트를 담은 대화형 지도를 만들 수 있습니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "제작한 지도를 다른 학생들과 공유하여 여러 명이 동시에 각자 맡은 장소를 지도에 추가하는 협업이 가능하다.",
                    "rationale": "구글 문서도구처럼 공유 및 동시 편집 기능이 지원되므로, 팀원들이 각자 조사한 내용을 하나의 지도 위에 함께 구축해나가는 프로젝트 학습에 매우 유용합니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "지도의 특정 지역에 대한 인구 통계 데이터를 실시간으로 분석하여 보여준다.",
                    "rationale": "내 지도는 사용자가 직접 정보를 추가하여 맞춤형 지도를 만드는 도구이며, 전문적인 지리 정보 시스템(GIS)처럼 실시간 인구 통계 분석 기능은 제공하지 않습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "경로 그리기 도구를 사용하여 역사적 인물의 이동 경로를 선으로 표시하고, 총 거리를 자동으로 계산할 수 있다.",
                    "rationale": "지점과 지점을 잇는 경로를 그리거나 특정 지역의 면적을 계산하는 기능이 포함되어 있어, 역사적 사건이나 지리적 변화를 시각적으로 표현하는 데 효과적입니다.",
                    "isCorrect": true
                  }
                ],
                "hint": "단순한 길 찾기 지도를 넘어, 우리만의 이야기가 담긴 특별한 '대화형 지도'를 만든다고 생각해 보세요.",
                "type": "multiple"
              },
              {
                "question": "아래 표는 '프로젝트 과제'의 각 단계를 설명한 것입니다. 각 단계에 가장 효율적으로 사용될 수 있는 '구글 도구'를 올바르게 연결하세요.<br><br><b>프로젝트 단계</b><br>A. 팀원들과 자유롭게 아이디어를 쓰고 그리며 브레인스토밍하기<br>B. 역할 분담 및 마감일 등 주요 일정을 정하고 공유하기<br>C. 각자 수집한 자료를 하나의 문서로 합치고 함께 보고서 작성하기<br>D. 최종 결과물을 청중 앞에서 효과적으로 발표하기<br><br><b>구글 도구</b><br>1. Google 캘린더<br>2. Google 슬라이드<br>3. Jamboard<br>4. Google 문서",
                "answerOptions": [
                  {
                    "text": "A-3, B-1, C-4, D-2",
                    "rationale": "각 단계의 핵심 활동(아이디어 발산, 역할 분담 및 일정 관리, 자료 취합 및 공동 작성, 최종 발표)에 가장 적합한 도구들을 정확하게 연결했습니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "A-1, B-2, C-3, D-4",
                    "rationale": "이 조합은 캘린더로 브레인스토밍을 하거나, 잼보드로 최종 발표를 하는 등 각 도구의 주된 용도와 맞지 않는 연결을 포함하고 있습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "A-3, B-4, C-1, D-2",
                    "rationale": "슬라이드로 역할을 분담하거나 캘린더로 자료를 취합하는 것은 매우 비효율적인 방식입니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "A-4, B-3, C-2, D-1",
                    "rationale": "문서로 발표를 하거나 잼보드로 일정을 관리하는 등, 각 단계의 목적에 맞지 않는 도구 선택이 포함되어 있습니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "각 단계의 핵심 동사(아이디어 내기, 계획하기, 만들기, 보여주기)에 가장 어울리는 도구를 생각해 보세요.",
                "type": "single"
              },
              {
                "question": "구글 클래스룸의 '주제' 기능을 사용하는 가장 주된 교육적 목적은 무엇인가요?",
                "answerOptions": [
                  {
                    "text": "특정 주제에 관심 있는 학생들만 따로 그룹으로 묶기 위해",
                    "rationale": "학생을 그룹으로 묶는 것은 클래스룸의 기본 기능이 아니며, '주제'는 학생이 아닌 콘텐츠를 분류하는 기능입니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "과제, 자료, 공지사항 등을 단원이나 주차별로 체계적으로 정리하여 학생들이 학습 자료를 쉽게 찾도록 하기 위해",
                    "rationale": "수업 스트림에 흩어져 있는 게시물들을 폴더처럼 묶어주어, 학생들이 학습 흐름에 따라 콘텐츠를 순서대로 확인하고 관리할 수 있도록 돕는 것이 핵심 목적입니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "게시물의 중요도에 따라 색깔을 다르게 표시하기 위해",
                    "rationale": "'주제'별로 목록이 나뉠 뿐, 게시물 자체의 색깔이나 디자인을 변경하는 기능은 아닙니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "주제별로 과제 마감일을 한 번에 설정하기 위해",
                    "rationale": "과제 마감일은 각 과제 게시물마다 개별적으로 설정해야 하며, 특정 주제에 속한 모든 과제의 마감일을 일괄적으로 지정하는 기능은 없습니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "온라인 서점의 '카테고리'나 컴퓨터의 '폴더'가 하는 역할을 생각해 보세요. 왜 그것들을 사용할까요?",
                "type": "single"
              },
              {
                "question": "한 교사가 구글 폼을 사용하여 온라인 퀴즈를 만들었습니다. 학생들이 퀴즈를 제출한 후, <b>자신이 어떤 문제를 틀렸는지 바로 확인하되, 정답은 알려주지 않도록</b> 설정하고 싶습니다. 어떤 설정을 조합해야 할까요?",
                "answerOptions": [
                  {
                    "text": "응답 > 설정 탭에서 '응답 수정 허용'을 켠다.",
                    "rationale": "이것은 학생들이 제출 후 답을 고칠 수 있게 하는 설정으로, 점수 공개 방식과는 관련이 없습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "퀴즈 설정에서 '성적 공개'를 '제출 후 바로 공개'로 하고, '응답자가 볼 수 있는 항목'에서 '정답'의 체크를 해제한다.",
                    "rationale": "이 조합은 학생들이 점수와 함께 틀린 문제는 무엇인지 즉시 확인하면서도, 정답 자체는 노출되지 않도록 하는 정확한 설정 방법입니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "퀴즈 설정에서 '성적 공개'를 '수동 검토 후 공개'로 설정한다.",
                    "rationale": "이렇게 하면 학생들이 제출 직후 아무것도 확인할 수 없게 되므로, 틀린 문제를 바로 확인하고 싶다는 요구사항과 맞지 않습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "프레젠테이션 설정에서 '질문 순서 무작위로 섞기'를 사용한다.",
                    "rationale": "이것은 부정행위를 방지하기 위한 옵션으로, 결과 공개 방식과는 아무런 관련이 없습니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "퀴즈 설정 메뉴에는 점수를 언제 공개할지와 '무엇을' 보여줄지를 분리하여 제어하는 옵션이 있습니다.",
                "type": "single"
              },
              {
                "question": "다음 중 구글 워크스페이스(Google Workspace) 도구 간의 연동 기능을 가장 잘 활용한 사례는 무엇인가요?",
                "answerOptions": [
                  {
                    "text": "구글 문서로 작성한 보고서를 PDF로 다운로드하여 이메일에 첨부해서 보낸다.",
                    "rationale": "이것은 각 도구를 개별적으로 사용하는 것이지, 도구 간의 유기적인 연동 기능을 활용한 사례로 보기는 어렵습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "구글 설문지로 만족도 조사를 실시하고, 그 결과를 자동으로 생성된 구글 스프레드시트에서 차트로 만들어 분석한 후, 그 차트를 구글 슬라이드 발표 자료에 삽입한다.",
                    "rationale": "설문지 → 스프레드시트 → 슬라이드로 이어지는 데이터의 흐름은, 각기 다른 도구들이 마치 하나처럼 유기적으로 연결되어 시너지를 내는 가장 대표적인 연동 사례입니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "Jamboard에서 그린 그림을 스크린샷으로 찍어 구글 드라이브에 업로드한다.",
                    "rationale": "Jamboard 파일을 드라이브에 바로 저장할 수 있는데 스크린샷을 이용하는 것은 번거로운 방식이며, 자동화된 연동의 장점을 활용하지 못하는 예시입니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "구글 캘린더에 시험 날짜를 기록하고, 구글 Keep에 시험공부 계획을 따로 작성한다.",
                    "rationale": "두 도구를 각자의 목적에 맞게 사용하고는 있지만, 캘린더의 일정과 Keep의 메모가 직접적으로 연결되어 상호작용하는 것은 아니므로 최적의 연동 사례는 아닙니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "하나의 작업이 다른 작업으로 자연스럽게 이어지면서, 데이터가 여러 도구를 거쳐 변환되고 활용되는 과정을 생각해 보세요.",
                "type": "single"
              },
              {
                "question": "구글 드라이브에서 파일을 검색할 때, `type:presentation owner:me` 라고 검색했습니다. 이 검색 결과로 나타나는 것은 무엇인가요?",
                "answerOptions": [
                  {
                    "text": "모든 사용자가 소유한 모든 프레젠테이션 파일",
                    "rationale": "owner:me 라는 조건이 있기 때문에 '모든 사용자'가 아닌 '나 자신'이 소유한 파일로 범위가 제한됩니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "내가 소유한 모든 유형의 파일",
                    "rationale": "type:presentation 이라는 조건이 있기 때문에 '모든 유형'이 아닌 '프레젠테이션' 파일만 검색 결과에 나타납니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "내가 소유한 모든 프레젠테이션(Google 슬라이드) 파일",
                    "rationale": "검색 연산자를 정확히 해석했습니다. 'type:'은 파일 유형을, 'owner:'는 소유자를 지정하는 필터이며, 'me'는 현재 로그인한 나 자신을 의미합니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "다른 사람이 소유하고 나에게 공유해 준 프레젠테이션 파일",
                    "rationale": "다른 사람이 소유한 파일을 찾으려면 'owner:상대방이메일주소'를 사용하거나, 검색창에서 '나와 공유된 항목'을 필터링해야 합니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "검색어에 포함된 `type`, `owner`, `me`가 각각 무엇을 의미하는지 생각해 보세요. 이것은 고급 검색 연산자입니다.",
                "type": "single"
              },
              {
                "question": "교사가 Gmail의 '템플릿(Templates)' 기능을 사용하면 어떤 이점을 얻을 수 있습니까?",
                "answerOptions": [
                  {
                    "text": "학생들이 보낸 이메일의 맞춤법을 자동으로 수정해준다.",
                    "rationale": "템플릿은 미리 작성된 메일을 저장하는 기능이며, 수신한 메일의 내용을 수정하는 기능은 없습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "특정 시간에 이메일이 발송되도록 예약할 수 있다.",
                    "rationale": "이메일 예약 발송은 '보내기' 버튼 옆의 드롭다운 메뉴에서 설정하는 별도의 기능이며, 템플릿 기능과는 다릅니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "자주 보내는 내용(예: 과제 피드백, 학부모 안내문)을 미리 저장해두고 클릭 몇 번으로 빠르게 불러와 사용할 수 있다.",
                    "rationale": "이것이 템플릿 기능의 핵심입니다. 반복적인 타이핑을 줄여 교사의 업무 효율을 획기적으로 높여줍니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "받은 이메일을 자동으로 번역하여 보여준다.",
                    "rationale": "이메일 번역은 Gmail에 내장된 별도의 기능으로, 사용자가 직접 실행해야 하며 템플릿과는 관련이 없습니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "발표자가 발표 화면과 청중 질문 관리 창을 동시에 볼 수 있는 '발표자 보기' 모드 안에 숨겨진 기능을 찾아보세요.",
                "type": "single"
              },
              {
                "question": "다음 중 Google Workspace의 접근성(Accessibility) 기능과 그에 대한 설명으로 올바르게 연결된 것을 <b>모두 고르세요.</b>",
                "answerOptions": [
                  {
                    "text": "음성 입력(Voice Typing) - 구글 문서나 슬라이드에서 키보드 대신 목소리로 텍스트를 입력하는 기능",
                    "rationale": "시각 장애나 지체 장애가 있는 사용자가 손쉽게 문서를 작성할 수 있도록 돕는 대표적인 접근성 기능입니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "화면 해설기(Screen Reader) 지원 - Chrome 브라우저 및 Workspace 앱들이 화면의 텍스트를 음성으로 읽어주는 기능과 호환됨",
                    "rationale": "시각 장애가 있는 사용자가 화면의 정보를 소리로 파악하여 앱을 탐색하고 사용할 수 있도록 지원합니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "실시간 자막(Live Captions) - Google Meet에서 발표자의 말을 실시간으로 텍스트 자막으로 보여주는 기능",
                    "rationale": "청각 장애가 있는 사용자나 시끄러운 환경에 있는 사용자가 회의 내용을 이해하는 데 큰 도움을 줍니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "자동 완성(Autofill) - 구글 설문지에서 이전 응답을 바탕으로 현재 질문의 답을 자동으로 완성해주는 기능",
                    "rationale": "자동 완성은 편의 기능일 수는 있지만, 장애가 있는 사용자를 돕기 위해 설계된 핵심적인 '접근성' 기능으로 분류되지는 않습니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "신체적 조건과 관계없이 모든 사람이 기술을 동등하게 이용할 수 있도록 돕는 기능들을 생각해 보세요.",
                "type": "multiple"
              },
              {
                "question": "학생이 구글 학술 검색(Google Scholar)을 사용하여 연구 보고서를 작성하고 있습니다. 검색 결과의 신뢰도를 높이기 위해 사용할 수 있는 전략으로 가장 적절한 것은 무엇인가요?",
                "answerOptions": [
                  {
                    "text": "검색 결과 중 가장 상단에 노출되는 논문을 항상 우선적으로 인용한다.",
                    "rationale": "검색 순위가 항상 신뢰도나 중요도와 일치하는 것은 아니므로, 비판적인 검토 없이 상위 노출 자료만 인용하는 것은 좋은 전략이 아닙니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "최신 연구 동향을 파악하기 위해 검색 도구에서 '최근 연도'로 기간을 설정하고, 인용 횟수가 높은 논문을 중심으로 살펴본다.",
                    "rationale": "기간을 설정하여 연구의 시의성을 확보하고, 동료 연구자들에게 많이 인용된 논문을 중심으로 살펴보는 것은 해당 분야에서 영향력 있고 신뢰도 높은 연구를 판별하는 효과적인 방법입니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "논문 제목에 '블로그'나 '뉴스'라는 단어가 포함된 자료 위주로 찾는다.",
                    "rationale": "학술 검색은 동료 심사(peer-review)를 거친 학술 논문을 찾는 것이 주 목적이므로, 블로그나 뉴스 기사는 신뢰도 높은 학술 자료로 보기 어렵습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "논문의 저자 이름이 익숙한 사람의 것만 선택한다.",
                    "rationale": "저자의 명성도 참고할 수는 있지만, 그것만이 유일한 기준이 되어서는 안 되며, 연구 내용과 방법론을 객관적으로 평가해야 합니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "신뢰도 높은 연구는 '최신 정보'이면서, 다른 전문가들로부터 '많은 인정'을 받았을 가능성이 높습니다.",
                "type": "single"
              },
              {
                "question": "교사가 Chrome 웹 스토어에서 교육용 확장 프로그램을 설치하려고 합니다. 학생들의 개인 정보 보호와 보안을 위해, 설치 전에 반드시 확인해야 할 사항으로 가장 중요한 것은 무엇입니까?",
                "answerOptions": [
                  {
                    "text": "확장 프로그램의 아이콘 디자인이 예쁜지 확인한다.",
                    "rationale": "디자인은 기능이나 보안과는 아무런 관련이 없는 주관적인 요소입니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "많은 사용자가 설치했는지, 긍정적인 사용자 리뷰가 많은지 확인하고, 개발자가 요구하는 '권한' 목록을 꼼꼼히 살핀다.",
                    "rationale": "인기나 평판도 중요하지만, 가장 중요한 것은 '이 확장 프로그램이 내 데이터 중 어디까지 접근을 요구하는가'를 확인하는 것입니다. 불필요하게 과도한 권한을 요구하는 앱은 보안 위험이 있을 수 있습니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "확장 프로그램의 업데이트 날짜가 가장 최신인지 확인한다.",
                    "rationale": "최신 업데이트 여부도 좋은 지표 중 하나이지만, 앱이 요구하는 권한을 직접 확인하는 것보다 중요하지는 않습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "유료 확장 프로그램인지 무료 확장 프로그램인지 확인한다.",
                    "rationale": "가격과 보안 수준이 항상 비례하는 것은 아닙니다. 무료이면서 안전한 앱도 많고, 유료이면서 과도한 정보를 요구하는 앱도 있을 수 있습니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "스마트폰에 앱을 설치할 때 '이 앱은 다음 권한에 액세스합니다...' 라는 메시지를 본 적이 있나요? 그것을 왜 확인해야 할까요?",
                "type": "single"
              },
              {
                "question": "구글 아트 앤 컬처(Google Arts & Culture)의 'Art Camera' 기능을 활용한 수업 활동으로 가장 적절한 것은 무엇인가요?",
                "answerOptions": [
                  {
                    "text": "스마트폰 카메라로 우리 교실의 모습을 찍어 예술 작품처럼 편집한다.",
                    "rationale": "Art Camera는 내가 직접 사진을 찍는 기능이 아니라, 박물관의 작품을 기가픽셀 수준의 초고화질로 촬영한 이미지를 확대하여 감상하는 기능입니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "반 고흐의 '별이 빛나는 밤'을 확대하여 유화 물감의 질감과 붓 터치를 세밀하게 관찰하고 감상문을 작성한다.",
                    "rationale": "이것이 Art Camera 기능의 핵심입니다. 육안으로는 볼 수 없는 작품의 미세한 부분까지 탐색하며, 작가의 기술과 의도를 깊이 있게 감상할 수 있습니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "자신의 셀카 사진과 가장 닮은 초상화를 찾아본다.",
                    "rationale": "이것은 'Art Selfie'라는 별도의 재미있는 기능으로, 초고화질로 작품을 감상하는 Art Camera와는 목적이 다릅니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "3D로 구현된 박물관 내부를 스트리트 뷰처럼 돌아다닌다.",
                    "rationale": "이것은 '뮤지엄 뷰(Museum View)'라는 기능으로, 공간을 탐험하는 것이 목적이며 특정 작품 하나를 세밀하게 들여다보는 Art Camera와는 다릅니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "돋보기로 그림을 들여다보듯, 미술 작품의 아주 작은 부분까지 확대해서 볼 수 있는 기능을 생각해 보세요.",
                "type": "single"
              },
              {
                "question": "수업 중 학생이 실수로 구글 드라이브에 있는 중요 발표 자료를 <b>영구적으로 삭제</b>했습니다. (휴지통에서도 비웠습니다.) 이 파일을 복구하기 위해 교사가 시도해 볼 수 있는 방법은 무엇인가요? (단, 학교가 Google Workspace for Education을 사용한다고 가정합니다.)",
                "answerOptions": [
                  {
                    "text": "학생의 컴퓨터 시스템을 이전 시점으로 복원한다.",
                    "rationale": "구글 드라이브 파일은 클라우드에 저장되므로, 로컬 컴퓨터의 시스템 복원과는 아무런 관련이 없습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "Google Workspace 관리자에게 문의하여 최근 삭제된 사용자 데이터를 복원해 줄 것을 요청한다.",
                    "rationale": "Education 버전의 관리자는 관리 콘솔에서 사용자의 데이터가 영구 삭제된 후 일정 기간(보통 25일) 내에 데이터를 복원할 수 있는 권한을 가지고 있습니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "다른 학생에게 혹시 파일을 공유받았는지 물어본다.",
                    "rationale": "만약 다른 학생이 사본을 가지고 있다면 파일을 되살릴 수 있지만, 원본 파일 자체를 복구하는 방법은 아닙니다. 관리자 복원이 불가능할 때 시도해 볼 차선책입니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "파일이 영구 삭제되었으므로 어떤 방법으로도 복구할 수 없다.",
                    "rationale": "개인용 구글 계정에서는 맞는 말일 수 있지만, 관리자가 있는 Google Workspace 환경에서는 일정 기간 복원이 가능합니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "개인 사용자가 할 수 없는 일을 학교나 회사의 '관리자'는 할 수 있는 경우가 있습니다. 데이터 관리 권한을 생각해 보세요.",
                "type": "single"
              },
              {
                "question": "학생이 구글 슬라이드로 발표 자료를 만들고 있습니다. 발표 시 청중의 질문을 실시간으로 받고, 그 질문들을 화면에 표시하여 상호작용을 높이고 싶어 합니다. 어떤 기능을 사용해야 할까요?",
                "answerOptions": [
                  {
                    "text": "댓글 기능",
                    "rationale": "댓글 기능은 편집 과정에서 의견을 주고받는 용도이며, 실시간 발표 중에 청중과 소통하기 위한 기능은 아닙니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "발표자 노트",
                    "rationale": "발표자 노트는 발표자 자신만 볼 수 있는 대본으로, 청중과의 상호작용과는 관련이 없습니다.",
                    "isCorrect": false
                  },
                  {
                    "text": "발표자 보기의 '청중 도구' (Q&A 세션)",
                    "rationale": "슬라이드쇼를 시작하고 발표자 보기로 전환하면, 청중이 스마트폰 등으로 접속하여 질문을 제출할 수 있는 Q&A 세션을 시작할 수 있습니다. 제출된 질문을 선별하여 발표 화면에 띄울 수도 있습니다.",
                    "isCorrect": true
                  },
                  {
                    "text": "탐색(Explore) 기능",
                    "rationale": "탐색 기능은 콘텐츠와 관련된 레이아웃이나 웹 검색 결과를 추천해주는 것으로, 실시간 청중 소통 기능은 아닙니다.",
                    "isCorrect": false
                  }
                ],
                "hint": "발표자가 발표 화면과 청중 질문 관리 창을 동시에 볼 수 있는 '발표자 보기' 모드 안에 숨겨진 기능을 찾아보세요.",
                "type": "single"
              }
            ]
        };

        let currentQuestions = [];
        let userAnswers = [];
        let currentQuestionIndex = 0;
        const baseScore = 10;

        function startQuiz() {
            const allQuestions = quizData.questions;
            currentQuestions = allQuestions.slice(0, 20); // 20개로 제한 (현재 18개)
            userAnswers = new Array(currentQuestions.length).fill(null).map(() => []);

            const totalQuestions = currentQuestions.length;
            const maxScore = baseScore + (totalQuestions * 5);
            document.querySelector('.header p').textContent = `총 ${totalQuestions}문제 | 문제당 5점 | 기본 ${baseScore}점 | 만점 ${maxScore}점`;
            
            document.getElementById('navigation').style.display = 'flex';
            
            showQuestion(currentQuestionIndex);

            document.getElementById('nextBtn').addEventListener('click', handleNext);
            document.getElementById('prevBtn').addEventListener('click', handlePrev);
        }

        function showQuestion(index) {
            const form = document.getElementById('quizForm');
            form.innerHTML = ''; // Clear previous question

            const question = currentQuestions[index];
            
            const questionDiv = document.createElement('div');
            questionDiv.className = 'question-card';
            
            const questionNumber = document.createElement('div');
            questionNumber.className = 'question-number';
            questionNumber.textContent = `문제 ${index + 1}`;
            
            const questionText = document.createElement('div');
            questionText.className = 'question-text';
            questionText.innerHTML = question.question;
            
            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'options';
            
            question.answerOptions.forEach((option, optionIndex) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';
                
                const label = document.createElement('label');
                const input = document.createElement('input');
                
                if (question.type === 'multiple') {
                    input.type = 'checkbox';
                } else {
                    input.type = 'radio';
                }
                input.name = `question${index}`;
                input.value = optionIndex;

                // Restore saved answer
                if (userAnswers[index] && userAnswers[index].includes(optionIndex)) {
                    input.checked = true;
                }
                
                const optionText = document.createElement('span');
                optionText.textContent = option.text;
                
                label.appendChild(input);
                label.appendChild(optionText);
                optionDiv.appendChild(label);
                optionsDiv.appendChild(optionDiv);
            });
            
            const hint = document.createElement('div');
            hint.className = 'hint';
            hint.textContent = question.hint;
            
            questionDiv.appendChild(questionNumber);
            questionDiv.appendChild(questionText);
            questionDiv.appendChild(optionsDiv);
            questionDiv.appendChild(hint);
            
            form.appendChild(questionDiv);

            updateNavigation(index);
        }

        function saveCurrentAnswer() {
            const inputs = document.querySelectorAll(`input[name="question${currentQuestionIndex}"]`);
            const selectedAnswers = [];
            inputs.forEach(input => {
                if (input.checked) {
                    selectedAnswers.push(parseInt(input.value));
                }
            });
            userAnswers[currentQuestionIndex] = selectedAnswers;
        }

        function handleNext() {
            saveCurrentAnswer();
            if (currentQuestionIndex < currentQuestions.length - 1) {
                currentQuestionIndex++;
                showQuestion(currentQuestionIndex);
            } else {
                submitQuiz();
            }
        }

        function handlePrev() {
            saveCurrentAnswer();
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                showQuestion(currentQuestionIndex);
            }
        }
        
        function updateNavigation(index) {
            document.getElementById('questionCounter').textContent = `${index + 1} / ${currentQuestions.length}`;
            document.getElementById('prevBtn').style.visibility = (index === 0) ? 'hidden' : 'visible';
            
            const nextBtn = document.getElementById('nextBtn');
            if (index === currentQuestions.length - 1) {
                nextBtn.textContent = '📊 답안 제출하기';
            } else {
                nextBtn.textContent = '다음';
            }
        }

        function submitQuiz() {
            let score = baseScore;
            
            currentQuestions.forEach((question, index) => {
                const selectedAnswers = userAnswers[index];
                
                if (question.type === 'multiple') {
                    const correctAnswers = question.answerOptions
                        .map((option, idx) => option.isCorrect ? idx : -1)
                        .filter(idx => idx !== -1);
                    
                    const isCorrect = selectedAnswers.length === correctAnswers.length &&
                        selectedAnswers.every(answer => correctAnswers.includes(answer));
                    
                    if (isCorrect) score += 5;
                } else {
                    const correctAnswer = question.answerOptions.findIndex(option => option.isCorrect);
                    if (selectedAnswers.length > 0 && selectedAnswers[0] === correctAnswer) {
                        score += 5;
                    }
                }
            });
            
            document.getElementById('quizForm').style.display = 'none';
            document.getElementById('navigation').style.display = 'none';
            displayResults(score);
        }

        function displayResults(score) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            
            const scoreDisplay = document.createElement('div');
            scoreDisplay.className = 'score-display';
            
            const scoreNumber = document.createElement('div');
            scoreNumber.className = 'score-number';
            scoreNumber.textContent = `${score}점`;
            
            const scoreText = document.createElement('div');
            scoreText.className = 'score-text';

            const totalQuestions = currentQuestions.length;
            const totalScore = baseScore + totalQuestions * 5;
            const percentage = totalScore > 0 ? (score / totalScore * 100).toFixed(0) : 0;
            scoreText.textContent = `총 ${totalScore}점 중 ${score}점 (${percentage}%)`;
            
            scoreDisplay.appendChild(scoreNumber);
            scoreDisplay.appendChild(scoreText);
            resultsDiv.appendChild(scoreDisplay);
            
            // 문제별 결과 표시
            currentQuestions.forEach((question, index) => {
                const questionResult = document.createElement('div');
                const selectedAnswers = userAnswers[index];
                
                let isCorrect = false;
                let correctAnswers = [];
                
                if (question.type === 'multiple') {
                    correctAnswers = question.answerOptions
                        .map((option, idx) => option.isCorrect ? idx : -1)
                        .filter(idx => idx !== -1);
                    
                    isCorrect = selectedAnswers.length === correctAnswers.length &&
                        selectedAnswers.every(answer => correctAnswers.includes(answer));
                } else {
                    const correctAnswer = question.answerOptions.findIndex(option => option.isCorrect);
                    correctAnswers = [correctAnswer];
                    isCorrect = selectedAnswers.length > 0 && selectedAnswers[0] === correctAnswer;
                }
                
                questionResult.className = `question-result ${isCorrect ? 'correct' : 'incorrect'}`;
                
                const resultHeader = document.createElement('div');
                resultHeader.className = 'result-header';
                
                const resultIcon = document.createElement('span');
                resultIcon.className = 'result-icon';
                resultIcon.textContent = isCorrect ? '✅' : '❌';
                
                const resultText = document.createElement('span');
                resultText.textContent = `문제 ${index + 1}: ${isCorrect ? '정답' : '오답'}`;
                
                resultHeader.appendChild(resultIcon);
                resultHeader.appendChild(resultText);
                
                const questionText = document.createElement('div');
                questionText.innerHTML = `<strong>문제:</strong> ${question.question}`;
                questionText.style.marginBottom = '10px';
                
                const userAnswerText = document.createElement('div');
                if (selectedAnswers.length === 0) {
                    userAnswerText.innerHTML = '<strong>당신의 답:</strong> (선택하지 않음)';
                } else {
                    const selectedTexts = selectedAnswers.map(idx => question.answerOptions[idx].text);
                    userAnswerText.innerHTML = `<strong>당신의 답:</strong> ${selectedTexts.join(', ')}`;
                }
                userAnswerText.style.marginBottom = '10px';
                
                const correctAnswerText = document.createElement('div');
                const correctTexts = correctAnswers.map(idx => question.answerOptions[idx].text);
                correctAnswerText.innerHTML = `<strong>정답:</strong> ${correctTexts.join(', ')}`;
                correctAnswerText.style.marginBottom = '10px';
                
                // 정답에 대한 해설 표시
                const rationale = document.createElement('div');
                rationale.className = 'rationale';
                const correctOption = question.answerOptions.find(option => option.isCorrect);
                rationale.textContent = correctOption.rationale;
                
                questionResult.appendChild(resultHeader);
                questionResult.appendChild(questionText);
                questionResult.appendChild(userAnswerText);
                questionResult.appendChild(correctAnswerText);
                questionResult.appendChild(rationale);
                
                resultsDiv.appendChild(questionResult);
            });
            
            const retryBtn = document.createElement('button');
            retryBtn.className = 'retry-btn';
            retryBtn.textContent = '🔄 다시 시험보기';
            retryBtn.onclick = () => {
                location.reload();
            };
            
            resultsDiv.appendChild(retryBtn);
            resultsDiv.style.display = 'block';
            
            // 결과 위치로 스크롤
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }

        // 페이지 로드 시 퀴즈 생성
        document.addEventListener('DOMContentLoaded', function() {
            startQuiz();
        });
    </script>
</body>
</html>